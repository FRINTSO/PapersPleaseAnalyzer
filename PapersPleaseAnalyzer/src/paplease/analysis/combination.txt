File game_analyzer.h:
"""
class GameAnalyzer
{
public:
	constexpr GameAnalyzer()
		: m_analysisContext(), m_documentPipeline(m_analysisContext)
	{}
	void Scan(const GameView& gameView);

private:
	void UpdateAnalysisContext();

	bool IsNewDate(const documents::data::Date& date) const noexcept;
	bool IsNewApplicant(int applicantNumber) const noexcept;

	void OnNewDate();
	void OnNewApplicant();

private:
	// Per scan
	const GameView* m_currentGameView = nullptr;
	scannable::ScanContext m_currentScanContext;

	// States
	DocPipeline m_documentPipeline;

	// Data
	AnalysisContext m_analysisContext;
};
"""

File doc_pipeline.h:
"""
// Common class containing all things pertaining to documents
class DocPipeline
{
    /*
    * Location of the actual document - where it is on screen
    * Analysis - a document should only be analyzed once, it has to be a fully valid analysis, repeat until it is
    * 
    * DocView <- Skeleton
    * Doc <- Actual document
    * DocData <- Data of document
    * 
    * DocTracker   - makes sure that the required documents are actually supplied, knows which documents should exist,
    *                finds the documents, keeps track of their coordinates, which ones are visible, etc.
    *                should continue to keep track of location always, however should fail to pass to next step in the pipeline,
    *                if a successful scan of the document has been completed.
    * 
    * DocValidator - makes sure that the snapshop of a document is correct, once it is, it should block if the same type comes in again
    *                this could also be the step where the doc data is extracted and passed into the DocAnalyzer.
    * 
    * DocAnalyzer  - makes an analysis of a document, and checks the information, against static data, against rules, against other documets, etc.
    * 
    */
public:
    constexpr DocPipeline(AnalysisContext& analysisContext)
        : m_store(),
        m_tracker(m_store, analysisContext),
        m_validator(m_store, analysisContext),
        m_analyzer(m_store, analysisContext)
    {}

    void Process(const scannable::ScanContext& scanContext);

    void Clear();

private:
    bool ProcessSingleDocument(documents::DocType documentType, const GameView& gameView);

private:
    DocTracker  m_tracker;
    DocValidator  m_validator;
    DocAnalyzer   m_analyzer;
    DocStore      m_store;

    friend class GameAnalyzer;
};
"""

File doc_tracker.h:
"""
class DocTracker
{
private:
    static inline constexpr size_t DocTypeCount = static_cast<size_t>(documents::DocType::Count);
    using DocTypeSet = core::FixedHashSet<documents::DocType, DocTypeCount>;
public:
    constexpr DocTracker(DocStore& store, AnalysisContext& analysisContext)
        : m_store(store), m_context(analysisContext) {}

    void RefreshTracking(const scannable::ScanContext& scanContext);

    // Get documents that have changed in appearance since last scan
    DocTypeSet GetVisibleDocuments() const;

    DocTypeSet GetUpdatedDocuments() const;


    void AddRequiredDocument(std::pair<documents::DocType, documents::PassportType> docType);

    void UpdateRequiredDocuments();

    void ReportMissingDocuments() const noexcept;

private:
    void RegisterScannedDocuments(const scannable::DocViewCollection& scannedDocuments);
    void RegisterSingleScannedDocument(documents::DocView&& scannedDocView);
            
private:
    DocStore& m_store;
    AnalysisContext& m_context;
            
    core::FixedHashSet<documents::DocType, DocTypeCount> m_visibleDocuments{};
    //core::FixedHashTable<
    //    std::pair<
    //        documents::DocType,
    //        documents::PassportType
    //    >,
    //    bool,
    //    DocTypeCount,
    //    detail::HashPair
    //> m_requiredDocuments;
};
"""

File doc_validator.h:
"""
// Class for storing documents
class DocValidator
{
public:
    constexpr DocValidator(DocStore& store, AnalysisContext& analysisContext)
        : m_store(store), m_context(analysisContext) {}

    bool ValidateDocument(documents::DocType documentType, const GameView& gameView);

private:
    DocStore& m_store;
    AnalysisContext& m_context;
};
"""

File doc_analyzer.h:
"""
class DocAnalyzer
{
public:
    constexpr DocAnalyzer(DocStore& store, AnalysisContext& analysisContext)
        : m_store(store), m_context(analysisContext) {}

    bool AnalyzeDocumentData(documents::DocType documentType);

private:
    bool AnalyzeEntrantDocument(documents::DocType documentType);
    bool AnalyzeRuleBook();
    bool AnalyzeTranscript();

    class DocValidator
    {
	public:
		constexpr DocValidator(
			AnalysisContext& analysisContext,
			const documents::Doc& document,
			const documents::DocData& documentData
		)
			: m_context(analysisContext),
			m_document(document),
			m_documentData(documentData)
		{}

		bool Validate();

	private:
		// Against static information, ex. Issuing city, or current date
		bool ValidateExpirationDate() const;
		bool ValidateIssuingCity() const;
		bool ValidateDistrict() const;
		bool ValidateForgedOrMissingSeal() const;
		bool ValidateEntryTicketValidOnDate() const;
		bool ValidateIssuingCountry() const;
		bool ValidateAccessToAristotzka() const;
		bool ValidateMissingVaccine() const;
		bool ValidateVaccineExpirationDate() const;
		bool ValidatePurpose() const;

		// Against booth
		bool ValidateWeight() const;

		// Against images - not supported yet
		bool ValidateSex() const;
		bool ValidatePhoto() const;
		bool ValidateHeight() const;
		bool ValidatePhysicalAppearance() const;
		bool ValidateThumbprint() const;
		bool ValidateFingerprints() const;

		// Against other applicant documents
		bool ValidateName() const;
		bool ValidateDateOfBirth() const;
		bool ValidatePassportNumber() const;
		bool ValidateWorkEndDate() const;

	private:
		AnalysisContext& m_context;
		const documents::Doc& m_document;  // The document being validated
		const documents::DocData& m_documentData;
    };

private:
    DocStore& m_store;
    AnalysisContext& m_context;
};
"""

File doc_store.h:
"""
struct DocAnalysisStatus
{
    // Requirements
    bool isRequired = false;  // Document is expected based on current rules
    bool isRequiredReported = false;

    // Processing state
    bool wasScanned = false;  // Document has been detected on screen
    bool wasValidated = false;  // Data has been successfully extracted from the document
    bool wasAnalyzed = false;  // Document content has been analyzed for rule compliance

    // Conflict status
    bool hasConflict = false;  // A discrepancy or issue was found in the document
    bool conflictCleared = false;  // The discrepancy has been resolved or cleared
};

struct DocRequirement
{
    documents::DocType documentType;
    documents::PassportType passportType = documents::PassportType::Invalid;

    constexpr bool operator==(const DocRequirement& other) const noexcept
    {
        return documentType == other.documentType &&
            passportType == other.passportType;
    }
};

namespace detail {

    struct HashPair
    {
        template <typename T, typename U>
        std::size_t operator()(const std::pair<T, U>& p) const
        {
            auto h1 = std::hash<T>{}(p.first);  // Hash the first element
            auto h2 = std::hash<U>{}(p.second); // Hash the second element

            // Combine the hashes using a standard method
            return h1 ^ (h2 << 1);  // Simple XOR and shift combination
        }
    };

    struct DocumentRequirementHash
    {
        std::size_t operator()(const DocRequirement& r) const noexcept
        {
            return HashPair{}(std::pair{ r.documentType, r.passportType });
        }
    };

}  // namespace detail

// Class for storing documents
class DocStore
{
private:
    template<typename ValueType>
    using DocHashTable = core::FixedHashTable<documents::DocType, ValueType, static_cast<size_t>(documents::DocType::Count)>;

public:
    const documents::DocView& StoreDocumentView(documents::DocView&& documentView);
    const documents::Doc& StoreDocument(documents::Doc&& document);
    const documents::DocData& StoreDocumentData(documents::DocType documentType, documents::DocData&& documentData);


    template<typename DocClass>
    constexpr const DocHashTable<DocClass>& GetStoredCollection() const
    {
        if constexpr (std::is_same_v<DocClass, documents::DocView>)
        {
            return m_storedDocumentViews;
        }
        else if constexpr (std::is_same_v<DocClass, documents::Doc>)
        {
            return m_storedDocuments;
        }
        else if constexpr (std::is_same_v<DocClass, documents::DocData>)
        {
            return m_storedDocumentData;
        }
        else
        {
            static_assert(false);
        }
    }
    template<typename DocClass>
    constexpr DocHashTable<DocClass>& GetStoredCollection()
    {
        if constexpr (std::is_same_v<DocClass, documents::DocView>)
        {
            return m_storedDocumentViews;
        }
        else if constexpr (std::is_same_v<DocClass, documents::Doc>)
        {
            return m_storedDocuments;
        }
        else if constexpr (std::is_same_v<DocClass, documents::DocData>)
        {
            return m_storedDocumentData;
        }
        else
        {
            static_assert(false);
        }
    }
    template<typename DocClass>
    constexpr const DocClass& GetStored(documents::DocType documentType) const
    {
        if constexpr (std::is_same_v<DocClass, documents::DocView>)
        {
            return m_storedDocumentViews[documentType];
        }
        else if constexpr (std::is_same_v<DocClass, documents::Doc>)
        {
            return m_storedDocuments[documentType];
        }
        else if constexpr (std::is_same_v<DocClass, documents::DocData>)
        {
            return m_storedDocumentData[documentType];
        }
        else
        {
            static_assert(false);
        }
    }
    template<typename DocClass>
    constexpr DocClass& GetStored(documents::DocType documentType)
    {
        if constexpr (std::is_same_v<DocClass, documents::DocView>)
        {
            return m_storedDocumentViews[documentType];
        }
        else if constexpr (std::is_same_v<DocClass, documents::Doc>)
        {
            return m_storedDocuments[documentType];
        }
        else if constexpr (std::is_same_v<DocClass, documents::DocData>)
        {
            return m_storedDocumentData[documentType];
        }
        else
        {
            static_assert(false);
        }
    }
    template<typename DocClass>
    constexpr bool Contains(documents::DocType documentType) const
    {
        if constexpr (std::is_same_v<DocClass, documents::DocView>)
        {
            return m_storedDocumentViews.Contains(documentType);
        }
        else if constexpr (std::is_same_v<DocClass, documents::Doc>)
        {
            return m_storedDocuments.Contains(documentType);
        }
        else if constexpr (std::is_same_v<DocClass, documents::DocData>)
        {
            return m_storedDocumentData.Contains(documentType);
        }
        else
        {
            static_assert(false);
        }
    }

    DocAnalysisStatus& GetAnalysisStatus(documents::DocType documentType);
    const core::FixedHashSet<DocRequirement, static_cast<size_t>(documents::DocType::Count), detail::DocumentRequirementHash>&
        GetRequiredTypes() const noexcept;

    void SetRequiredType(DocRequirement requiredType);

    void Clear()
    {
        // Store rulebook
        auto type = documents::DocType::RuleBook;
        documents::DocView* pdocView = nullptr;
        documents::Doc* pdoc = nullptr;
        documents::DocData* pdocData = nullptr;
        m_storedDocumentViews.Get(type, pdocView);
        m_storedDocuments.Get(type, pdoc);
        m_storedDocumentData.Get(type, pdocData);
        auto& docStatus = m_storedDocumentAnalysisStatus.Get(type);

        // Clear
        m_storedDocumentViews.Clear();
        m_storedDocuments.Clear();
        m_storedDocumentData.Clear();
        m_storedDocumentAnalysisStatus.Clear();
        m_requiredDocuments.Clear();

        // Add rulebook
        if (pdocView)
            m_storedDocumentViews.Set(type, *pdocView);
        if (pdoc)
            m_storedDocuments.Set(type, *pdoc);
        if (pdocData)
            m_storedDocumentData.Set(type, *pdocData);
        m_storedDocumentAnalysisStatus.Set(type, docStatus);
    }

private:
    DocHashTable<documents::DocView> m_storedDocumentViews{};
    DocHashTable<documents::Doc> m_storedDocuments{};
    DocHashTable<documents::DocData> m_storedDocumentData{};
            
    core::FixedTable<documents::DocType, DocAnalysisStatus> m_storedDocumentAnalysisStatus{};
    core::FixedHashSet<DocRequirement, static_cast<size_t>(documents::DocType::Count), detail::DocumentRequirementHash> m_requiredDocuments{};
};
"""

File analysis_context.h:
"""
struct TrackedRule
{
    enum class Status : u8 { Unmet, Complied, Broken };

    data::Rule rule;
    Status status;
};

class AnalysisContext
{
public:
    void SetEntrantCountry(data::ECountry country);
    void SetEntrantDistrict(data::EDistrict district);
    void SetEntrantCity(data::ECity city);
    void SetEntrantClassification(u8 classification);

    bool AddToProfile(const documents::Field& fieldData);

    bool HasRulebook() const noexcept;
    bool HasTranscript() const noexcept;

    const data::RuleBook& GetRulebook() const;
    const data::Transcript& GetTranscript() const;

    void SetRulebook(data::RuleBook&& rulebook);
    void SetTranscript(data::Transcript&& transcript);

    const core::FixedHashTable<data::ERule, TrackedRule, 10>& GetApplicableRules() const;

    void OnNewDate();
    void OnNewApplicant();

public:
    void SetBoothFields(const scannable::BoothData& boothData);

    // Booth
    std::optional<documents::data::Date> currentDate;
    std::optional<documents::data::SIUnitValue> currentWeight;
    std::optional<documents::data::SIUnitValue> approximateHeight;
    int applicantNumber;

private:
    void UpdateRules();

private:
    // Store
    data::EntrantInfo m_entrant;
    data::Profile     m_profile;

    // Special document types
    std::optional<data::RuleBook> m_rulebook = std::nullopt;
    std::optional<data::Transcript> m_transcript = std::nullopt;
            
    // Rules
    core::FixedHashTable<data::ERule, TrackedRule, 10> m_applicableRules;
};
"""

File entrant_data.h:
"""
namespace data {

    struct EntrantClass : public core::EnumBase<u8>
    {
        using EnumBase::EnumBase;
        enum : u8
        {
            Entrant       = 0b00'00'00'00,   // All instances of this is an entrant

            // Entrant specialization, must be one of these
            Citizen       = 0b00'00'00'01,   // bitflag
            Foreigner     = 0b00'00'00'10,   // bitflag

            // Foreigner specialization, must be one of these
            Worker        = 0b00'00'01'10,
            Diplomat      = 0b00'00'10'10,
            AsylumSeeker  = 0b00'00'11'10,

            // Other, must be one of these
            FromKolechia  = 0b00'01'00'10,
            FromImpor     = 0b00'10'00'10,
            FromUnitedFed = 0b00'11'00'10,

            // Citizen specialization
            FromAltanDistrict = 0b01'00'00'01,
        };

        static inline constexpr u8 CountryMask = 0b00'00'00'11;
        static inline constexpr size_t Count = 10;
                
        constexpr bool IsCitizen() const noexcept
        {
            return (m_data & Citizen) == Citizen;
        }
        constexpr bool IsForeigner() const noexcept
        {
            return (m_data & Foreigner) == Foreigner;
        }

        constexpr bool IsWorker() const noexcept
        {
            return m_data == Worker;
        }
        constexpr bool IsDiplomat() const noexcept
        {
            return m_data == Diplomat;
        }
        constexpr bool IsAsylumSeeker() const noexcept
        {
            return m_data == AsylumSeeker;
        }

        constexpr bool IsFromKolechia() const noexcept
        {
            return (m_data & FromKolechia) == FromKolechia;
        }
        constexpr bool IsFromImpor() const noexcept
        {
            return (m_data & FromImpor) == FromImpor;
        }
        constexpr bool IsFromUnitedFed() const noexcept
        {
            return (m_data & FromUnitedFed) == FromUnitedFed;
        }

        constexpr bool IsFromAltanDistrict() const noexcept
        {
            return (m_data & FromAltanDistrict) == FromAltanDistrict;
        }

        constexpr bool IsTarget(ERuleTarget ruleTarget) const noexcept
        {
            switch (ruleTarget)
            {
                case ERuleTarget::Invalid:
                    return false;
                case ERuleTarget::Entrant:
                    return true;
                case ERuleTarget::Citizens:
                    return IsCitizen();
                case ERuleTarget::Foreigners:
                    return IsForeigner();
                case ERuleTarget::Workers:
                    return IsWorker();
                case ERuleTarget::Diplomats:
                    return IsDiplomat();
                case ERuleTarget::AsylumSeekers:
                    return IsAsylumSeeker();
                case ERuleTarget::Kolechians:
                    return IsFromKolechia();
                case ERuleTarget::FromImpor:
                    return IsFromImpor();
                case ERuleTarget::FromUnitedFederation:
                    return IsFromUnitedFed();
                case ERuleTarget::FromAltanDistrict:
                    return IsFromAltanDistrict();
            }
        }
    };

    struct EntrantInfo
    {
        EntrantClass entrantClass = EntrantClass::Entrant;
        ECountry nationality = ECountry::Invalid;
        EDistrict district = EDistrict::Invalid;
        ECity city = ECity::Invalid;

        void SetNationaility(ECountry country)
        {
            if ((entrantClass & entrantClass.CountryMask) != 0)
            {
                LOG_WARN("Setting country twice");
            }
            else
            {
                if (country == ECountry::Arstotzka)
                {
                    entrantClass |= data::EntrantClass::Citizen;
                    LOG("Is citizen");
                }
                else
                {
                    entrantClass |= data::EntrantClass::Foreigner;
                    LOG("Is foreigner");
                }
            }
                    
            nationality = country;
        }
        void SetEntrantDistrict(EDistrict district)
        {
            this->district = district;
        }
        void SetEntrantCity(ECity city)
        {
            this->city = city;
        }

    };

}
"""

File profile.h:
"""
namespace data {

    class Profile
    {
    public:
        static constexpr int MatchingData = 1;
        static constexpr int NoData = 0;
        static constexpr int MismatchingData = -1;

        bool RegisterData(const documents::Field& fieldData)
        {
            auto result = this->CompareData(fieldData);
            if (result == MismatchingData)
            {
                return false;
            }
            else if (result == NoData)
            {
                m_fields.Set(fieldData.Category(), fieldData);
            }

            return true;
        }
    private:
        int CompareData(const documents::Field& fieldData) const
        {
            if (!m_fields.Contains(fieldData.Category()))
            {
                return NoData;
            }

            const auto& storedData = m_fields[fieldData.Category()];

            bool isIdenticalData = storedData.GetData() == fieldData.GetData();

            return isIdenticalData ? MatchingData : MismatchingData;
        }

        static constexpr size_t FieldsCapacity = 20;
    private:
        core::FixedHashTable<documents::FieldCategory, documents::Field, FieldsCapacity> m_fields;
    };

}
"""

File rules.h:
"""
namespace data {
    enum class ERule : u8
    {
        Invalid = static_cast<u8>(-1),

        // === REQUIREMENTS ===
        RequireCurrentDocumentsFromEntrant = 0, // If this flag is set, mediator should know what functions to call
        RequirePassportFromEntrant,
        RequireArstotzkanPassportFromEntrant,
        RequireIdentityCardFromCitizens,
        RequireEntryTicketFromForeigners,
        RequireWorkPassFromWorkers,
        RequireDiplomaticAuthorizationFromDiplomats,
        RequireIdentitySupplementFromForeigners,
        RequireGrantFromAsylumSeekers,
        RequirePolioVaccinationFromEntrant,
        RequireAccessPermitFromForeigners,
        RequireEntryPermitFromForeigners,
        RequireSearchOfKolechians,

        // === PROHIBITIONS ===
        ProhibitEntryFromImpor,
        ProhibitEntryFromUnitedFederation,        // something to realize when
        ProhibitWeaponsAndContrabandFromEntrant,  // needs to be same weight 

        // === CONFISCATIONS ===
        ConfiscateArstotzkanPassportsFromAltanDistrict,
        ConfiscateArstotzkanPassportFromEntrant,

        Count
    };

    // Scan order:
    // All entrants require passport (RequirePassportFromEntrant)
    // 1. Passport belongs to citizen
    //  -> Require id card (RequireIdentityCardFromCitizens)
    //  .
    // 2. Passport belongs to foreigner
    //  -> Require EntryTicket (RequireEntryTicketFromForeigners)
    //  .
    //  -> Require IdentitySupplement (RequireIdentitySupplementFromForeigners)
    //  -> Require AccessPermit (RequireAccessPermitFromForeigners)
    //  -> Require EntryPermit (RequireEntryPermitFromForeigners)
    // 
    //

    enum class ERuleAction : u8
    {
        Invalid = static_cast<u8>(-1),
        Require = 0,    // Need information
        Prohibit,   // Limit
        Confiscate  // Limit
    };

    enum class ERuleSubject : u8
    {
        Invalid = static_cast<u8>(-1),
        CurrentDocuments = 0,
        Passport,
        ArstotzkanPassport,
        IdentityCard,
        EntryTicket,
        WorkPass,
        DiplomaticAuthorization,
        IdentitySupplement,
        Grant,
        PolioVaccination,
        AccessPermit,
        EntryPermit,
        WeaponsAndContraband,
        Search,
        Entry,
    };

    static inline constexpr DocRequirement ERuleSubjectToDocType(ERuleSubject subject)
    {
        switch (subject)
        {
            case ERuleSubject::Passport:
                return { documents::DocType::Passport, documents::PassportType::Invalid };
            case ERuleSubject::ArstotzkanPassport:
                return { documents::DocType::Passport, documents::PassportType::Arstotzka };
            case ERuleSubject::IdentityCard:
                return { documents::DocType::IdentityCard, documents::PassportType::Invalid };
            case ERuleSubject::EntryTicket:
                return { documents::DocType::EntryTicket, documents::PassportType::Invalid };
            case ERuleSubject::WorkPass:
                return { documents::DocType::WorkPass, documents::PassportType::Invalid };
            case ERuleSubject::DiplomaticAuthorization:
                return { documents::DocType::DiplomaticAuthorization, documents::PassportType::Invalid };
            case ERuleSubject::IdentitySupplement:
                return { documents::DocType::IdentitySupplement, documents::PassportType::Invalid };
            case ERuleSubject::Grant:
                return { documents::DocType::GrantOfAsylum, documents::PassportType::Invalid };
            case ERuleSubject::PolioVaccination:
                return { documents::DocType::CertificateOfVaccination, documents::PassportType::Invalid };
            case ERuleSubject::AccessPermit:
                return { documents::DocType::AccessPermit, documents::PassportType::Invalid };
            case ERuleSubject::EntryPermit:
                return { documents::DocType::EntryPermit, documents::PassportType::Invalid };
            default:
                return { documents::DocType::Invalid, documents::PassportType::Invalid };
        }
    }

    enum class ERuleTarget : u8
    {
        Invalid = static_cast<u8>(-1),
        Entrant = 0,
        Citizens,
        Foreigners,
        Workers,
        Diplomats,
        AsylumSeekers,
        Kolechians,
        FromImpor,
        FromUnitedFederation,
        FromAltanDistrict
    };

    struct RuleDescriptor
    {
        constexpr RuleDescriptor() = default;
        constexpr RuleDescriptor(ERuleAction action, ERuleSubject subject, ERuleTarget target)
            : action{action}, subject{subject}, target{target}
        {}

        ERuleAction action = ERuleAction::Invalid;
        ERuleSubject subject = ERuleSubject::Invalid;
        ERuleTarget target = ERuleTarget::Invalid;
    };

    class Rule
    {
    public:
        constexpr Rule() = default;
        constexpr Rule(ERule rule, RuleDescriptor descriptor)
            : m_rule{ rule }, m_descriptor{ descriptor }
        {}

    public:
        // void ApplyRule() const;
        ERule GetRule() const;
        std::string_view GetDescription() const;
        const RuleDescriptor& GetDescriptor() const;
    private:
        ERule m_rule = ERule::Invalid;
        RuleDescriptor m_descriptor{};
    };

    class RuleBook
    {
    public:
        RuleBook() = default;
        static constexpr size_t MaxRuleCount = 10;

        const core::FixedArray<Rule, MaxRuleCount>& GetRules() const
        {
            return m_activeRules;
        }
                
    private:
        void RegisterRule(ERule rule);

    private:
        core::FixedArray<Rule, MaxRuleCount> m_activeRules{};

        friend std::optional<RuleBook> CreateRuleBook(const documents::Doc& document);
    };
}
"""

File transcript.h:
"""
namespace data {
    enum class SpeakerRole
    {
        Invalid = 0,
        Applicant,
        Inspector
    };

    class TranscriptEntry
    {
    private:
        SpeakerRole m_speakerRole;
        std::string m_dialogueLine;
    };

    class Transcript
    {
    public:
        Transcript() = default;

        friend std::optional<Transcript> CreateTranscript(const documents::Doc& document);
    private:
        static constexpr size_t MaxTranscriptEntries = 10;
    private:
        core::FixedArray<TranscriptEntry, MaxTranscriptEntries> m_entries;
    };
}
"""

File scan_context.h:
"""
namespace scannable {
			
	struct ScanContext
	{
		const GameView* currentGameView;
		scannable::BoothData boothData;
		scannable::InspectionData inspectionData;
	};

	scannable::ScanContext Scan(const GameView& gameView);

}  // namespace scannable
"""

File booth.h:
"""
namespace scannable {
	struct BoothData
	{
		// Data
		std::optional<documents::data::Date> date;
		std::optional<documents::data::SIUnitValue> weight;
		std::optional<documents::data::SIUnitValue> approximateHeight;
		std::optional<cv::Mat> applicantHeadshot;
		std::optional<int> applicantNumber;

		DocViewCollection scannedDocuments;

		// Methods
		std::optional<cv::Mat> ExtractSilhouette() const;
		std::optional<cv::Mat> ExtractHead() const;
		std::optional<cv::Mat> ExtractFace() const;
		std::optional<cv::Mat> ExtractBinaryHeadshot() const;

		documents::data::Photo PhotoToBinaryHeadshotPhoto() const;
	};
	BoothData ScanBooth(const GameView& gameView);
}  // namespace scannable
"""

File inspection.h:
"""
namespace scannable {
	struct InspectionData
	{
		DocViewCollection scannedDocuments;
	};
	InspectionData ScanInspection(const GameView& gameView);
}  // namespace scannable
"""